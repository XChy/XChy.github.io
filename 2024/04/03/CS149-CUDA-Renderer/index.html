<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Georgia:300,300italic,400,400italic,700,700italic|hack:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xchy.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. Introduction It&#39;s always hard to write code for parallel programs, and harder to write correct and fast code on GPU. Writing a simple CUDA Renderer would be an opportunity to practice.">
<meta property="og:type" content="article">
<meta property="og:title" content="CS149 Asst3 -- CUDA Renderer">
<meta property="og:url" content="http://xchy.github.io/2024/04/03/CS149-CUDA-Renderer/index.html">
<meta property="og:site_name" content="XChy&#39;s Blog">
<meta property="og:description" content="1. Introduction It&#39;s always hard to write code for parallel programs, and harder to write correct and fast code on GPU. Writing a simple CUDA Renderer would be an opportunity to practice.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/stanford-cs149/asst3/master/handout/order.jpg">
<meta property="og:image" content="http://xchy.github.io/images/CUDA-Renderer/cpu-split-profile.png">
<meta property="og:image" content="http://xchy.github.io/images/CUDA-Renderer/cpu-performance.png">
<meta property="og:image" content="http://xchy.github.io/images/CUDA-Renderer/cpu-split-profile1.png">
<meta property="og:image" content="http://xchy.github.io/images/CUDA-Renderer/final-result.png">
<meta property="article:published_time" content="2024-04-03T09:15:59.000Z">
<meta property="article:modified_time" content="2024-04-04T13:39:28.263Z">
<meta property="article:author" content="XChy">
<meta property="article:tag" content="Parallel Computing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/stanford-cs149/asst3/master/handout/order.jpg">

<link rel="canonical" href="http://xchy.github.io/2024/04/03/CS149-CUDA-Renderer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CS149 Asst3 -- CUDA Renderer | XChy's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XChy's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">For life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">43</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/XChy" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://xchy.github.io/2024/04/03/CS149-CUDA-Renderer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/doge.jpg">
      <meta itemprop="name" content="XChy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XChy's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS149 Asst3 -- CUDA Renderer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-03 17:15:59" itemprop="dateCreated datePublished" datetime="2024-04-03T17:15:59+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-04 21:39:28" itemprop="dateModified" datetime="2024-04-04T21:39:28+08:00">2024-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Parallel-Computing/" itemprop="url" rel="index"><span itemprop="name">Parallel Computing</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="introduction">1. Introduction</h2>
<p>It's always hard to write code for parallel programs, and harder to write correct and fast code on GPU. Writing a simple <a target="_blank" rel="noopener" href="https://github.com/stanford-cs149/asst3">CUDA Renderer</a> would be an opportunity to practice.</p>
<span id="more"></span>
<p>In this article, the CUDA version is 12.1, the GPU is GTX 3090.</p>
<h2 id="task">2. Task</h2>
<p>Given the positions, RGBs and other information of a bunch of circles(may be transparent), you need to implement a <strong>fastest</strong> and <strong>correct</strong> render function for these circles you can.</p>
<p>If we don't care about the <strong>order</strong> of circles, it would be just an easy programming assignment. However, the circles can be <strong>transparent</strong>, that is, we need to blend every pixel based on the original color in that pixel. The render uses the following math: <span class="math display">\[C_{new} = \alpha C_{i} + (1 - \alpha) C_{old}\]</span> Such composition is not commutative, so it's important to draw the pixel following the correct order:</p>
<figure>
<img src="https://raw.githubusercontent.com/stanford-cs149/asst3/master/handout/order.jpg" alt="" /><figcaption>order</figcaption>
</figure>
<h2 id="extract-parallelism-offical-prefix-sum">3. Extract Parallelism (Offical) (Prefix-Sum)</h2>
<p>So how can we make it parallel to render? An basic insight is that we could draw every pixel independently. Since nothing is required to share between pixels, we could render a pixel in the order of circles. The kernel function is just like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderPixel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.....;</span><br><span class="line">  <span class="type">int</span> pixelX, pixelY;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; total_pixels)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (circle : circles)</span><br><span class="line">    <span class="keyword">if</span> (pixel in circle) <span class="comment">// expensive</span></span><br><span class="line">      <span class="built_in">blend</span>(circle, pixelX, pixelY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Another insight is that, we could scan a bunch of circles once to see whether this pixel is in the circle. But how can we synchronize and reduce the result from one scan?</p>
<p><em>Parallel prefix-sum algorithm</em> makes sense here. Every thread in scan compute whether the pixel intersects one circle, then put the result in a boolean array <code>incircle</code>. By computing the prefix-sum of <code>incircle</code> parallelly, we get an result array <code>indexes</code> and the count of intersected circles. <code>indexes[i]</code> is the number of <strong>intersected</strong> circle son top of which ith circle lies. Knowing the indexes of circles that intersect, we could parallelize the renderer further(pseudocode):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderPixel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> index = threadIdx.....;</span><br><span class="line">  <span class="type">int</span> pixelX, pixelY;</span><br><span class="line">  <span class="type">int</span> scanIndex = ...;</span><br><span class="line">  <span class="type">int</span> countIntersected;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; total_pixels)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __shared__ <span class="type">int</span> incircle[SCANNUM];</span><br><span class="line">  __shared__ <span class="type">int</span> indexes[SCANNUM];</span><br><span class="line">  __shared__ <span class="type">int</span> circles[SCANNUM];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCircles; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (one of circle in every SCANNUM circles) </span><br><span class="line">      incircle[scanIndex] = (pixel in circle)</span><br><span class="line"></span><br><span class="line">      __syncthreads();</span><br><span class="line">      <span class="built_in">prefixSumParallel</span>(&amp;countIntersected, indexes);</span><br><span class="line">      __syncthreads();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Put into corresponding place</span></span><br><span class="line">      circles[indexes[scanIndex]] = scanIndex + i;</span><br><span class="line"></span><br><span class="line">      __syncthreads();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (scanIndex == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; countIntersected; j++)</span><br><span class="line">            <span class="built_in">drawCircle</span>(circles[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This solution looks generally good, but it <strong>cannot</strong> reach full points on my machine. I guess the cause is that, it's expensive to spawn a large amout of threads and synchronize them, especially there is just single circle in the scene.</p>
<p>To prevent synchronization and unnecessary threads, I propose another method to solve it.</p>
<hr />
<h2 id="extract-parallelism-split-space-into-boxes">4. Extract Parallelism (Split Space into Boxes)</h2>
<p>Confronted with this task, the first thing occurred to me is <strong>quad-tree</strong>, which splits space into multiple small boxes dynamically, so that we only need to check whether entities in the small box intersect. In this way, we avoid computing intersection for every entity in the whole space. Such technique is often applied in game engine.</p>
<p>In the solution above, to render a pixel, we need to check all circles in the scene and see whether they intersect the current pixel. That's <strong>UNNECESSARY</strong> indeed. If we split the scene into uninterleaved boxes and compute the intersected circles in each box, and only try to draw the circles in the same box with that of the pixel parallelly, many unnecessary <code>drawCircle</code> calls could be avoided. With such intuition, I handicraft a fast CUDA renderer by splitting the 2D scene space. In this section, I will show how I optimize my renderer step by step.</p>
<h3 id="split-space-on-cpu">4.1 Split Space on CPU</h3>
<p>Based on MISS principle in software engineering, We'd better write correct code first. And then consider improving it.</p>
<p>A trivial solution on CPU is to split the space into equally-sized boxes, computing intersection between circles and boxes, and copy the results to GPU.</p>
<p>Basic procedure is like: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allocate <span class="string">&quot;circlesInBox&quot;</span> <span class="built_in">array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> every circle</span><br><span class="line">    check which boxes overlap with the circle</span><br><span class="line">    <span class="keyword">for</span> overlapped boxes</span><br><span class="line">        put this circle index into circlesInBox[box]</span><br><span class="line"></span><br><span class="line">transfer data from CPU to GPU</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> every box</span><br><span class="line">    kernel_render_on_box&lt;&lt;&lt;...&gt;&gt;&gt;(box)</span><br></pre></td></tr></table></figure></p>
<p>This method won the score of <strong>20</strong> on my machine.</p>
<p>When I analyzed the performance bottleneck, my first thought was that <code>cudaMalloc</code> and the <code>cudaMemcpy</code> between host and device are slow and costly. Even worse, <code>cudaMemcpy</code> leads to all threads on device to synchronize, it's really, really <strong>slow</strong>. Meanwhile it's also expensive to spawn the kernel calls separately.</p>
<p>Let's prove the inference above. Run <code>nsys</code> on the renderer, and see the profiling information: <img src="/images/CUDA-Renderer/cpu-split-profile.png" /></p>
<p>Obivously, the latency of <code>cudaMalloc</code> and <code>cudaMemcpy</code> is a big overhead. Let's resolve this first!</p>
<h3 id="copy-the-memory-asynchronously">4.2 Copy the memory asynchronously</h3>
<p>The first thing I did is to replace <code>cudaMemcpy</code> with <code>cudaMemcpyAsync</code>. Though the <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-runtime-api/api-sync-behavior.html#api-sync-behavior__memcpy-async">document</a> warns:</p>
<blockquote>
<ol start="3" type="1">
<li>If pageable memory must first be staged to pinned memory, the driver may synchronize with the stream and stage the copy into pinned memory.</li>
</ol>
</blockquote>
<p>But reality is that <code>cudaMemcpyAsync</code> always runs asynchronously on my machine. This helps with reducing/hiding latency:</p>
<p><img src="/images/CUDA-Renderer/cpu-performance.png" /></p>
<p>This method overperforms <code>cpu-ref</code> in terms of speed for some tests. But it's not fast enough. Obviously, for <code>rand100k</code> and <code>biglittle</code> tests, we are slow. Let's profile again on <code>rand100k</code> test:</p>
<p><img src="/images/CUDA-Renderer/cpu-split-profile1.png" /></p>
<p><code>cudaMalloc</code> still plays a role as an overhead here. Further optimization needs parallelized splitting on <strong>GPU</strong>, preventing data allocations/moves from host to device.</p>
<h3 id="split-space-on-gpu">4.2 Split Space on GPU</h3>
<p>The split method on CPU focus on circles firstly, instead of boxes. On GPU, it's easier to focus on independent boxes parallelly. So the GPU splitting kernel is like: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findCirclesInBox</span><span class="params">()</span> &#123;</span><br><span class="line">    Box mybox = assignBox(thread index);</span><br><span class="line">    <span class="keyword">for</span> every circle</span><br><span class="line">        <span class="keyword">if</span> circle intersect mybox</span><br><span class="line">            <span class="title function_">addCircle</span><span class="params">(mybox, circle)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Greatly, this improve won the score of <strong>61</strong>. Now, the CUDA renderer with splitted space could compete the offical solution!</p>
<h3 id="reduce-memory-access-to-global-memory">4.3 Reduce Memory Access to Global Memory</h3>
<p>Traditional compilers reduce unnecessary memory access to register, which enhance performance of application especially when extracting memory access in loops (AFAIK, <em>LLVM</em> always perform this type of optimization in <em>LICM</em>). But for <em>CUDA</em>, it's impossible to do such optimization without knowing whether the memory position is accessed by other threads.</p>
<p>This is a snippet from kernel render function for every pixel: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float4* img = ...; <span class="comment">// A pointer pointing to a part of global variable</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numInBox; i++) &#123;</span><br><span class="line">    <span class="type">int</span> circleIndex3 = <span class="number">3</span> * circleIndexes[i];</span><br><span class="line">    float3 p = position[circleIndex3];</span><br><span class="line">    <span class="built_in">shade</span>(circleIndexes[i], ... , img); <span class="comment">// &quot;shade&quot; reads and writes &quot;img&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Global memory is a slow memory region in GPU. My intuition is to promote it to register:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4* img = ...; <span class="comment">// A pointer pointing to a part of global variable</span></span><br><span class="line">float4 imgTmp = *img; <span class="comment">// In register</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numInBox; i++) &#123;</span><br><span class="line">    <span class="type">int</span> circleIndex3 = <span class="number">3</span> * circleIndexes[i];</span><br><span class="line">    float3 p = position[circleIndex3];</span><br><span class="line">    <span class="built_in">shade</span>(circleIndexes[i], ... , &amp;imgTmp); <span class="comment">// &quot;shade&quot; now reads and writes a register</span></span><br><span class="line">&#125;</span><br><span class="line">*img = imgTmp;</span><br></pre></td></tr></table></figure>
<p>Surprisingly, the minor change make the renderer defeat <code>render_ref</code> completely and win score of <strong>72</strong> sometimes. Hard to imagine the impact it brought.</p>
<p>Take a look at the original <em>NVPTX</em> assembly by <code>cuobjdump -ptx</code>: <figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">...</span><br><span class="line">ld.global.v4.<span class="type">f32</span> &#123;%f65, %f66, %f67, %f68&#125;, [%rd4];</span><br><span class="line">...</span><br><span class="line">st.global.v4.<span class="type">f32</span> [%rd4], &#123;%f78, %f77, %f76, %f79&#125;;</span><br><span class="line">...</span><br><span class="line">@%p4 bra <span class="variable">$loop</span></span><br><span class="line"></span><br><span class="line">loopexit:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>And the assembly after change: <figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ld.global.v4.<span class="type">f32</span> &#123;%f65, %f66, %f67, %f68&#125;, [%rd4];</span><br><span class="line"></span><br><span class="line"><span class="keyword">loop</span>:</span><br><span class="line">...</span><br><span class="line">@%p4 bra <span class="variable">$loop</span></span><br><span class="line"></span><br><span class="line">loopexit:</span><br><span class="line">st.global.v4.<span class="type">f32</span> [%rd4], &#123;%f78, %f77, %f76, %f79&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure> It confirmed that the change makes sense.</p>
<p>Similarly, compiler cannot determine the equivalence of two loads of identical memory address. I imitated <em>CSE</em> (common sub-expression elimination) technique of compiler optimization, replace <code>circleIndexes[i]</code> with a common variable: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4* img = ...; <span class="comment">// A pointer pointing to a part of global variable</span></span><br><span class="line">float4 imgTmp = *img; <span class="comment">// In register</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numInBox; i++) &#123;</span><br><span class="line">    <span class="type">int</span> circleIndex3 = <span class="number">3</span> * circleIndexes[i];</span><br><span class="line">    float3 p = position[circleIndex3];</span><br><span class="line">    <span class="built_in">shade</span>(circleIndexes[i], ... , &amp;imgTmp); <span class="comment">// &quot;shade&quot; now reads and writes a register</span></span><br><span class="line">&#125;</span><br><span class="line">*img = imgTmp;</span><br></pre></td></tr></table></figure> to <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float4* img = ...; <span class="comment">// A pointer pointing to a part of global variable</span></span><br><span class="line">float4 imgTmp = *img; <span class="comment">// In register</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numInBox; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = circleindexes[i];</span><br><span class="line">    <span class="type">int</span> circleIndex3 = <span class="number">3</span> * index;</span><br><span class="line">    float3 p = position[circleIndex3];</span><br><span class="line">    <span class="built_in">shade</span>(index, ... , &amp;imgTmp); <span class="comment">// &quot;shade&quot; now reads and writes a register</span></span><br><span class="line">&#125;</span><br><span class="line">*img = imgTmp;</span><br></pre></td></tr></table></figure> Now the renderer become better and defeat the reference implementation!</p>
<p>But wait... Whether can we utilize parallelism of circles inside a box with shared memory and <strong>prefix-sum</strong>?</p>
<p>The result is <strong>BAD</strong>. By default, I split the scene into 128x128 boxes. And in most cases, the number of circles inside a box is less than 1000. Synchronizing a large bunch threads in a scan become a <strong>big</strong> overhead. In simple <code>rgb</code> scene, it runs for even over 10ms.</p>
<p>Also, I tried to do the <em>prefix-sum</em> algorithm in warp level. I guess warp-level synchronization primitives are cheaper. But the result is <strong>BAD</strong> too.</p>
<p>I think a better solution is to build a <em>quad-tree</em> parallelly and compute in tree node. Maybe I will implement it in my free time.</p>
<h2 id="final-result">5. Final Result</h2>
<p><img src="/images/CUDA-Renderer/final-result.png" /></p>
<h2 id="some-inspiration">6. Some inspiration</h2>
<ul>
<li><p>Threads in a warp always synchronize(converge). The GPU scheduler schedule by warps(instead of thread). Since GPU is always <em>SIMT/SIMD</em>, all threads in a warp execute identical instruction at a time. If threads in warp diverge, warp will go through every path. Thus warp must wait for one path even though other threads are inactive on this path. Anyway, if two threads in a warp wait for a spinning lock, that would be a dead lock.</p></li>
<li><p>Parallelism is <strong>not</strong> always better. <em>Amdahl's formula</em> proves it: <span class="math display">\[S = \frac{1}{1 - a + \frac{a}{n}}\]</span> And the overhead of parallelism would make it slower.</p></li>
<li><p>Memory Access should be considered seriously.<br />
Global memory, constant memory, register(on chip), local memory(on chip) differ in terms of speed and storage. To prevent memory bound, we should pick suitable memory region to handle data.</p></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Parallel-Computing/" rel="tag"><i class="fa fa-tag"></i> Parallel Computing</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/23/SMT-Introduction/" rel="prev" title="SMT-可满足性模理论">
      <i class="fa fa-chevron-left"></i> SMT-可满足性模理论
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task"><span class="nav-number">2.</span> <span class="nav-text">2. Task</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extract-parallelism-offical-prefix-sum"><span class="nav-number">3.</span> <span class="nav-text">3. Extract Parallelism (Offical) (Prefix-Sum)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extract-parallelism-split-space-into-boxes"><span class="nav-number">4.</span> <span class="nav-text">4. Extract Parallelism (Split Space into Boxes)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#split-space-on-cpu"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Split Space on CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-the-memory-asynchronously"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Copy the memory asynchronously</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#split-space-on-gpu"><span class="nav-number">4.3.</span> <span class="nav-text">4.2 Split Space on GPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce-memory-access-to-global-memory"><span class="nav-number">4.4.</span> <span class="nav-text">4.3 Reduce Memory Access to Global Memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-result"><span class="nav-number">5.</span> <span class="nav-text">5. Final Result</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#some-inspiration"><span class="nav-number">6.</span> <span class="nav-text">6. Some inspiration</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XChy"
      src="/images/doge.jpg">
  <p class="site-author-name" itemprop="name">XChy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/XChy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XChy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xxs_chy@outlook.com" title="E-Mail → mailto:xxs_chy@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XChy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
