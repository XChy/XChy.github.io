<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mathematica微积分常用命令</title>
    <url>/2023/02/06/Mathematica%E5%BE%AE%E7%A7%AF%E5%88%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>作为大一新生,每天都要为了数学作业焦头烂额，为了解决这个问题，聪慧的我想到了利用数学工具 Mathematica 来解决这个问题</p>
<p>于是我先用南大邮箱获得了 mma，并在 Ubuntu 上安装了 mma 及其依赖</p>
<p>下面记录有关求极限，求微分，以及求积分的几个模板</p>
<span id="more"></span>

<h2 id="极限-Limit"><a href="#极限-Limit" class="headerlink" title="极限(Limit)"></a>极限(Limit)</h2><p>我们要求得下列式子的极限：</p>
<p>$Assume {\quad} f’(a)&#x3D;\sqrt{2} {\quad} f’’(a)&#x3D;2$</p>
<p>$\lim_{x \rightarrow a} \frac{1}{f(x)-f(a)} - \frac{1}{(x-a)f’(x)} $</p>
<p>我们在 mma 可以输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Limit</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">-</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">-</span> <span class="variable">a</span><span class="punctuation">)</span> <span class="variable">f</span><span class="operator">&#x27;</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">,</span></span><br><span class="line"> <span class="built_in">Assumptions</span> <span class="operator">-&gt;</span> <span class="punctuation">&#123;</span><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="built_in">Sqrt</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">D</span><span class="punctuation">[</span><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="微分-x2F-导数-Derivative"><a href="#微分-x2F-导数-Derivative" class="headerlink" title="微分&#x2F;导数(Derivative)"></a>微分&#x2F;导数(Derivative)</h2><p>我们要求得下列函数的导数：</p>
<p>$f(x)&#x3D;\sin{x}^{\sin{x}}+\ln{\int_0^x{\sqrt{\tan{x}}dx}}$</p>
<p>我们在 mma 可以输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">_x</span><span class="punctuation">]</span><span class="operator">=...</span></span><br><span class="line"><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">,</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="积分-x2F-定积分-Integration"><a href="#积分-x2F-定积分-Integration" class="headerlink" title="积分&#x2F;定积分(Integration)"></a>积分&#x2F;定积分(Integration)</h2><p>我们要求得以下积分</p>
<p>$\int{\frac{1}{\cos^2{x}}dx}$</p>
<p>$\int_0^{\pi&#x2F;2}{\frac{1}{\cos^2{x}}dx}$</p>
<p>我们可以分别在 mma 输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Integrate</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">,</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Integrate</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">,</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span><span class="number">0</span><span class="operator">,</span><span class="built_in">Pi</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Mathematica</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(1)</title>
    <url>/2023/02/06/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-1/</url>
    <content><![CDATA[<p>网上有关Neovim API的中文资料实在稀缺，在此特意整理一部分</p>
<p>若英文水平过关，可以直接输入指令 <code>:h lua guide</code> 获得Neovim的Lua API相关英文文档</p>
<span id="more"></span>

<h2 id="Neovim’s-Lua-API"><a href="#Neovim’s-Lua-API" class="headerlink" title="Neovim’s Lua API"></a>Neovim’s Lua API</h2><ul>
<li><p><code>vim.keymap.set(mode , from_keys, to_expr, opts)</code></p>
<p> <em>作用:创建一个键位映射</em></p>
<p> <strong>mode</strong>：类型：<strong>string</strong>，映射作用的模式，”n”代表normal，”i”代表insert,”v”代表visual</p>
<p> <strong>from_keys</strong>：类型：<strong>string</strong>，则指被映射的按键</p>
<p> <strong>to_expr</strong>：类型：<strong>any</strong>，指映射得到的键位，vim表达式，或者Lua函数</p>
<p> <strong>opts</strong>：类型：<strong>table</strong>，键位映射有关的设置</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>vim.api.nvim_create_user_command(commandName, expr)</code></p>
<p> <em>作用:创建一个用户命令</em></p>
<p> <strong>commandName</strong>：类型：<strong>string</strong>， 命令名(必须首字母大写)</p>
<p> <strong>expr</strong>：类型：<strong>any</strong>，命令执行的键位，表达式或者Lua函数</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>vim.api.nvim_create_autocmd(event, opts)</code></p>
<p>  <em>作用:创建一个自动命令</em></p>
<p>  <strong>event</strong>：类型：<strong>string</strong>， 自动命令组(autogroup)</p>
<p>  <strong>opts</strong>：类型：<strong>table</strong>，相关设置：</p>
<ul>
<li><p><strong>pattern</strong>: 文件名的pattern</p>
</li>
<li><p><strong>callback</strong>: 自动命令的回调函数，可以是键位，vim表达式，或者Lua函数</p>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(2)</title>
    <url>/2023/02/08/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-2/</url>
    <content><![CDATA[<h3 id="使用-Lua-配置-Neovim，并设置自己的-workflow"><a href="#使用-Lua-配置-Neovim，并设置自己的-workflow" class="headerlink" title="使用 Lua 配置 Neovim，并设置自己的 workflow"></a>使用 Lua 配置 Neovim，并设置自己的 workflow</h3><h4 id="结合命令行工具"><a href="#结合命令行工具" class="headerlink" title="结合命令行工具"></a>结合命令行工具</h4><p>我在编码时常常有使用 git 的需求，但又不想总是在命令行中敲命令</p>
<p>于是我利用与 ToggleTerm 把命令行工具 lazygit 嵌入至 Neovim 中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> Terminal = <span class="built_in">require</span>(<span class="string">&#x27;toggleterm.terminal&#x27;</span>).Terminal</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lazygit = Terminal:new(&#123; cmd = <span class="string">&quot;lazygit&quot;</span>, direction = <span class="string">&#x27;float&#x27;</span>, hidden = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">local</span> top = Terminal:new(&#123; cmd = <span class="string">&quot;top&quot;</span>, direction = <span class="string">&#x27;float&#x27;</span>, hidden = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lazygit</span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;LazyGit&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        lazygit:toggle()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; nargs = <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- top</span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;Top&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        top:toggle()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; nargs = <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>同样类似的，还可以通过命令行工具 trans 进行翻译，并通过 neovim 的 api 将翻译结果显示出来.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">translate_terminal</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> mode = vim.api.nvim_get_mode()[<span class="string">&#x27;mode&#x27;</span>]</span><br><span class="line">    <span class="keyword">local</span> to_translate</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;n&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        to_translate = vim.fn.expand(<span class="string">&#x27;&lt;cword&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> mode == <span class="string">&#x27;v&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        to_translate = <span class="built_in">require</span>(<span class="string">&#x27;basic&#x27;</span>).get_visual_selection()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> command = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&#x27;trans &quot;%s&quot;&#x27;</span>, to_translate)</span><br><span class="line"></span><br><span class="line">    async.run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> translated_content = vim.fn.systemlist(command)</span><br><span class="line">        utils.show_term_content(translated_content)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置-Layout"><a href="#设置-Layout" class="headerlink" title="设置 Layout"></a>设置 Layout</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vim.api.nvim_create_user_command(</span><br><span class="line">    <span class="string">&quot;BufferDelete&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">---@diagnostic disable-next-line: missing-parameter</span></span><br><span class="line">        <span class="keyword">local</span> file_exists = vim.fn.filereadable(vim.fn.expand(<span class="string">&quot;%p&quot;</span>))</span><br><span class="line">        <span class="keyword">local</span> modified = vim.api.nvim_buf_get_option(<span class="number">0</span>, <span class="string">&quot;modified&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file_exists == <span class="number">0</span> <span class="keyword">and</span> modified <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> user_choice = vim.fn.<span class="built_in">input</span>(</span><br><span class="line">                    <span class="string">&quot;The file is not saved, whether to force delete? Press enter or input [y/n]:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> user_choice == <span class="string">&quot;y&quot;</span> <span class="keyword">or</span> <span class="built_in">string</span>.<span class="built_in">len</span>(user_choice) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                vim.cmd(<span class="string">&quot;bd!&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> force = <span class="keyword">not</span> vim.bo.buflisted <span class="keyword">or</span> vim.bo.buftype == <span class="string">&quot;nofile&quot;</span></span><br><span class="line"></span><br><span class="line">        vim.cmd(force <span class="keyword">and</span> <span class="string">&quot;bd!&quot;</span> <span class="keyword">or</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;bp | bd! %s&quot;</span>, vim.api.nvim_get_current_buf()))</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; desc = <span class="string">&quot;Delete the current Buffer while maintaining the window layout&quot;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="在-Neovim-中编辑-Hexo-blog"><a href="#在-Neovim-中编辑-Hexo-blog" class="headerlink" title="在 Neovim 中编辑 Hexo blog"></a>在 Neovim 中编辑 Hexo blog</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> blog_path = <span class="string">&quot;~/Documents/Hexo-Blog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogNew</span><span class="params">(input)</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;nvim-tree.api&#x27;</span>).tree.change_root(blog_path)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">output</span> = vim.fn.system(<span class="string">&quot;hexo n &quot;</span> .. <span class="string">&#x27;\&quot;&#x27;</span> .. <span class="built_in">input</span>.args .. <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vim.v.shell_error == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">path</span> = <span class="built_in">string</span>.<span class="built_in">sub</span>(<span class="built_in">output</span>, <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">output</span>, <span class="string">&#x27;~&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>), <span class="number">-1</span>)</span><br><span class="line">        vim.cmd(<span class="string">&quot;:e &quot;</span> .. <span class="built_in">path</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Failed creating new blog post&quot;</span> .. <span class="built_in">input</span>.args, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogNewDraft</span><span class="params">(input)</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;nvim-tree.api&#x27;</span>).tree.change_root(blog_path)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">output</span> = vim.fn.system(<span class="string">&quot;hexo new draft &quot;</span> .. <span class="string">&#x27;\&quot;&#x27;</span> .. <span class="built_in">input</span>.args .. <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vim.v.shell_error == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">path</span> = <span class="built_in">string</span>.<span class="built_in">sub</span>(<span class="built_in">output</span>, <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">output</span>, <span class="string">&#x27;~&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>), <span class="number">-1</span>)</span><br><span class="line">        vim.cmd(<span class="string">&quot;:e &quot;</span> .. <span class="built_in">path</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Failed creating new blog post&quot;</span> .. <span class="built_in">input</span>.args, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogGenerateAndDeploy</span><span class="params">()</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;hexo g &amp;&amp; hexo s&quot;</span>)) <span class="keyword">then</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Deploy the blog successfully&quot;</span>, <span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Deployment of blog failed&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="取消下一行注释"><a href="#取消下一行注释" class="headerlink" title="取消下一行注释"></a>取消下一行注释</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- avoid comment when enter the new line</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;BufEnter&quot;</span> &#125;, &#123;</span><br><span class="line">    pattern = <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        vim.opt.formatoptions = vim.opt.formatoptions - &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;o&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(3) (clangd &amp; CMake)</title>
    <url>/2023/03/01/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-3-Clangd---CMake/</url>
    <content><![CDATA[<p>在使用 Neovim 进行 C&#x2F;C++的开发时，我们常常使用 <strong>clangd</strong> 作为 <strong>lsp</strong> 提供语法高亮&#x2F;重构等语言服务</p>
<p>其中 clangd 根据自动推断宏的功能也是十分有效，搭配<strong>CMake</strong>可以达到更加好的效果(如支持 CMake 内置宏，支持自动 include CMake 配置的头文件)</p>
<p>下面提供简要的集成 clangd 与 cmake 的方法</p>
<p>一般来说<strong>clangd</strong>可以自动识别<strong>CMake</strong>生成的<strong>compile_commands.json</strong>来进行头文件的识别与宏的分析</p>
<p>但 compile_commands.json 不会自动生产，故我们可以通过以下命令实现 compile_commands 的自动生产</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake . -G -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br></pre></td></tr></table></figure>

<p>其中 <em><code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code></em> 是用于导出编译命令的 flag</p>
<p>故我常常会在项目目录下建立一个 build.sh 来构建项目:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake . -G -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>构建时只需要输入 build.sh</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-Mutable Variable的LLVM IR生成</title>
    <url>/2023/03/03/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-Mutable-Variable%E7%9A%84LLVM-IR%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h3 id="为什么需要-Mutable-Variable"><a href="#为什么需要-Mutable-Variable" class="headerlink" title="为什么需要 Mutable Variable?"></a>为什么需要 Mutable Variable?</h3><p>由于 LLVM 内部优化等原因，LLVM IR 中的寄存器必须遵循<strong>SSA</strong>原则，即每个寄存器在 SSA 中仅被赋值一次。</p>
<p>但由于 XSharp 需要支持同个变量的多次引用，我们不能直接使用寄存器作为变量的存储单元。</p>
<p>幸运的是，LLVM 并不强制要求栈上的变量保持<strong>SSA</strong>，所以我们可以考虑将所有变量存放在栈上，</p>
<p>然后再通过 LLVM 提供的 Mem2Reg 工具或者 Pass 进行栈上内存的数据流分析，尽可能地将栈上的变量转换至寄存器上。</p>
<p>原文档在此:<a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">LLVM Mutable Variable</a></p>
<p>而针对 XSharp,我们可以写出如下代码</p>
<span id="more"></span>

<p>首先，LLVM 通过<strong>AllocaInst</strong>分配栈上的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VariableDeclarationNode* varNode = <span class="built_in">get</span>();</span><br><span class="line">TypeNode* typenode = varNode-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> xsharpType = varNode-&gt;<span class="built_in">type</span>();</span><br><span class="line"><span class="keyword">auto</span> llvmValue =</span><br><span class="line">builder.<span class="built_in">CreateAlloca</span>(</span><br><span class="line">    <span class="built_in">llvmTypeFor</span>(xsharpType, context), <span class="literal">nullptr</span>,</span><br><span class="line">    varNode-&gt;<span class="built_in">name</span>().<span class="built_in">toStdString</span>());</span><br></pre></td></tr></table></figure>

<p>同时，也可以把函数的参数存在栈上，以下复制自 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">LLVM Tutorial</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>并用<strong>PromoteMemoryToRegisterPass</strong>实现 Mem2Reg 的优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promote allocas to registers.</span></span><br><span class="line">functionPassManager-&gt;<span class="built_in">add</span>(<span class="built_in">createPromoteMemoryToRegisterPass</span>());</span><br></pre></td></tr></table></figure>

<p>LLVM 也对性能等问题做了解释<br><img src="/images/Mem2RegLLVM.png" alt="content"></p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-Type</title>
    <url>/2023/02/18/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-Type/</url>
    <content><![CDATA[<h3 id="一个好的编程语言需要有一个好的类型系统"><a href="#一个好的编程语言需要有一个好的类型系统" class="headerlink" title="一个好的编程语言需要有一个好的类型系统"></a>一个好的编程语言需要有一个好的类型系统</h3><p>笔者计划为 XSharp 开发一个静态且可拓展的类型系统，其中支持基本类型(如<em>i32</em>,<em>i64</em>)，数组，函数，Closure，类等类型及其复合</p>
<p>而复合的需求就意味着类型必须是多层次，且多种类型的形式，而树这种数据结构正好符合要求</p>
<p>于是<strong>TypeNode</strong>出现了</p>
<p>我们社设计具体类型的<strong>类型相关</strong>设置，从而构建不同的类型结构，如 ArrayType 有 elementType 的子类型，FunctionType 有 paramTypes 的子节点列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arrayDimension指的是数组类型的维度</span></span><br><span class="line"><span class="comment">//而elementType则是元素类型的TypeNode指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayType</span> &#123;</span><br><span class="line">    uint arrayDimension;</span><br><span class="line">    TypeNode* elementType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//paramTypes指的是参数的类型</span></span><br><span class="line"><span class="comment">//returnValueType则是返回值的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FunctionType</span> &#123;</span><br><span class="line">    std::vector&lt;TypeNode*&gt; paramTypes;</span><br><span class="line">    TypeNode* returnValueType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>而<strong>TypeNode</strong>则用枚举<strong>Category</strong>表示类型的范畴，即<strong>类型相关</strong>的类型设置(<strong>typeSpecifiedInfo</strong>)的范畴</p>
<p>从而确定 TypeNode 的类型结构，使用<strong>std::variant</strong>使存储多种类型相关设置成为可能</p>
<p>搭配上<strong>Category</strong>，就可根据<strong>category</strong>解析 variant 类型的<strong>typeSpecifiedInfo</strong>，获得具体的类型信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeNode</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypeNode</span>();</span><br><span class="line">    <span class="built_in">TypeNode</span>(<span class="type">const</span> TypeNode&amp; other);</span><br><span class="line">    ~<span class="built_in">TypeNode</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equals</span><span class="params">(<span class="type">const</span> TypeNode&amp; other)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Basic type</span></span><br><span class="line">    <span class="function">BasicType <span class="title">basicType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function type, TODO complete below</span></span><br><span class="line">    <span class="function">TypeNode* <span class="title">returnValueType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;TypeNode*&gt; <span class="title">paramsType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array type, TODO complete below</span></span><br><span class="line">    <span class="function">uint <span class="title">arrayDimension</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">TypeNode* <span class="title">elementType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class type,  TODO complete below</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate a unique name for a type</span></span><br><span class="line">    <span class="function">XString <span class="title">typeName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    uint typeID;</span><br><span class="line">    XString baseName;</span><br><span class="line">    <span class="type">bool</span> isConst;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Categories</span> &#123; Basic, Array, Function, Closure, Class &#125; category;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;BasicType, ClassType, FunctionType, ArrayType, ClosureType&gt;</span><br><span class="line">        typeSpecifiedInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时注意到<strong>typeID</strong>，我们将会在编译时为特定类型分配<strong>唯一</strong>(<strong>unique</strong>)的 typeID，并通过 typeID 实现运行时反射</p>
<p>在 TypeSystem 中我们将实现这一功能</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<p>&lt;–more&gt;</p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog&#39;s configuration</category>
      </categories>
      <tags>
        <tag>Helloworld</tag>
        <tag>Blog&#39;s configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客文章</title>
    <url>/2023/02/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>奋战了 2 个小时后，终于成功用 Hexo 搭建了一个小博客。<br>本博客仅用于个人生活学习的记录，并无商业用途，若有友链或者交流需要，请通过我的邮箱<strong><a href="mailto:&#120;&#x78;&#115;&#x5f;&#99;&#104;&#x79;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#x2e;&#99;&#111;&#109;">&#120;&#x78;&#115;&#x5f;&#99;&#104;&#x79;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#x2e;&#99;&#111;&#109;</a></strong>联系我</p>
]]></content>
      <categories>
        <category>Blog&#39;s configuration</category>
      </categories>
      <tags>
        <tag>Helloworld</tag>
        <tag>Blog&#39;s configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-表达式解析-Pratt Parsing</title>
    <url>/2023/03/15/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-Pratt-Parsing/</url>
    <content><![CDATA[<p>手工实现 Parser 常用<strong>递归下降法(Recusive Descent)</strong>，XSharp 的 Parser 也采用了<strong>递归下降</strong>的主体结构。</p>
<p>一般来说递归下降法适用于自上而下的结构，更容易解析开头有标识符的语言，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但也由于同样的原因，递归下降法处理表达式非常吃力。Parser 在读到表达式开头的时候，无法知道自己身处哪种表达式之中，这是因为操作符往往在表达式的中间位置（甚至结尾），比如加法运算的+、函数调用的()。为了能自顶向下地解析表达式，你需要将每一种操作符 <strong>优先级(priority)</strong> 都单独作为一个层级，为其编写解析函数，并手动处理 <strong>结合性(associativity)</strong> ，因此解析函数会比较多、比较复杂。</p>
<p>所以在重构 XSharp 的 Parser 时，我选择了 <strong>Pratt Parsing</strong> 作为表达式的算法</p>
<p>笔者参考了 <a href="https://zhuanlan.zhihu.com/p/471075848">Pratt Parsing 知乎</a> 和 <a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">Pratt Parsing Rust</a> 进行了有关代码的重构</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ASTNode* lhs = <span class="built_in">operand</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStopwords</span>(current, stopwords)) <span class="keyword">return</span> lhs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;type != Operator)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">XSharpError</span>(<span class="string">&quot;No operator matched after operand&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">priority</span>(current-&gt;value) &lt;= ctxPriority) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    XString op = current-&gt;value;</span><br><span class="line"></span><br><span class="line">    forward();</span><br><span class="line">    <span class="keyword">auto</span> right_binding_power =</span><br><span class="line">        <span class="built_in">assoc</span>(op) == LeftToRight ? <span class="built_in">priority</span>(op) : <span class="built_in">priority</span>(op) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> rhs = <span class="built_in">expression</span>(stopwords, right_binding_power);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> new_lhs = <span class="keyword">new</span> BinaryOperatorNode;</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setOperatorStr</span>(op);</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setLeft</span>(lhs);</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setRight</span>(rhs);</span><br><span class="line">    lhs = new_lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lhs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>原理如下：</p>
<p>我们在解析表达式时，我们总是倾向于让<strong>priority</strong>较高的运算符与<strong>operand</strong>结合</p>
<p>故我们在已知左边表达式 lhs 时，从人类通常思维出发</p>
<p>我们倾向于在 op 的 priority 较高时拆散 lhs，让 op 不断与 lhs 最右边的 operand 结合直到优先级不足</p>
<p>而在 op 的 priority 较低时，让 op 与 lhs 整体结合</p>
<p>但这不符合机器从左到右解析的顺序，所以我们可以换一种思路</p>
<p>所以，我们从左向右扫描，设初始优先级为 0，从 priority 较低的层级出发，一步步找到优先级更高的运算符并结合</p>
<p>以表达式 <code>a / b = 2 + 5 * 6</code> 为例</p>
<p>初始层级优先级为 0，给当前层级命名 <strong>initial</strong></p>
<ul>
<li><p>进入 initial 层，我们先读入 token <strong>a</strong></p>
<p>发现 <strong>/</strong> 的优先级大于 0，于是结合 0 与/<br>并进入属于 <strong>‘/’</strong> 的层级，该层级优先级为 3，该层级求优先级大于 3 的 rhs</p>
<ul>
<li><p>然后读入 token <strong>b</strong>, b 属于 <strong>‘/’</strong> 层级，又读入 operator <strong>=</strong> 发现其优先级&lt;=当前层级最小优先级</p>
<p>于是结束 <strong>‘/’</strong> 层级， 确定其 rhs 为 b，得到一个整体 <code>(a / b)</code></p>
</li>
</ul>
</li>
<li><p>回到 initial 层，且此时 lhs 为<code>a / b</code>，继续读入 operator <strong>=</strong> ，其优先级为 1&gt;=0，故进入 <strong>‘=’</strong> 层</p>
<ul>
<li><p>现在读入 token <strong>2</strong>，再读入 operator <strong>+</strong>，发现其优先级 2&gt;=1 故可作为 rhs，进入 <strong>‘+’</strong> 层</p>
<ul>
<li><p>继续求 <strong>‘+’</strong> 的 rhs，发现 token <strong>5</strong>，和 operator <strong>*</strong> ，<strong>*</strong> 的优先级 3&gt;=2，故进入<strong>‘*‘</strong>层</p>
<ul>
<li>读入 <code>6</code> 表达式结束，将 6 作为 <strong>‘*‘</strong> 的 rhs，开始回溯</li>
</ul>
<p>将 <code>5 * 6</code> 作为 <strong>‘+’</strong> 的 rhs，退出 <strong>‘+’</strong> 层</p>
</li>
</ul>
<p>得到 <code>2 + (5*6)</code> ，将其作为 <strong>‘=’</strong> 的 rhs，退出 <strong>‘=’</strong> 层</p>
</li>
</ul>
</li>
</ul>
<p>最后回到<strong>initial</strong>层，结合已有 lhs：<code>a / b</code>, op: <code>=</code>, rhs <code>2 + ( 5 * 6 )</code>，返回<code>(a / b) = ( 2 + ( 5 * 6 ) )</code></p>
<p>至此基本算法结束，对于右结合的<strong>associativity</strong>可以通过降低其’右优先级‘来实现（如代码所示），其他高级特性可参考上面引用的文章</p>
<p>通过这个算法，我们成功把原本 200 行的复杂函数压缩到 20 行，且获得了更高的性能。</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp-4-Class-Design</title>
    <url>/2023/05/18/XSharp-4-Class-Design/</url>
    <content><![CDATA[<p>Waiting to complete</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-数组设计</title>
    <url>/2023/04/17/XSharp-3-Array-Design-0/</url>
    <content><![CDATA[<p>参考了 Java 中的对象模型<br>我决定把 XSharp 中的 <strong>数组(Array)</strong> 的模型设计为以下形式：<br>[ <strong>8</strong> bytes ] object header as <strong>length of array</strong><br>[ <strong>4 or 8</strong> bytes ] pointer <strong><em>p</em></strong> to a sequential memory (<strong>for elements</strong>)</p>
<p>故对以下 XSharp 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i64[] a = new i64[100]</span><br></pre></td></tr></table></figure>

<p>在 64 位系统上，我们将会在栈上分配 8 + 4 字节的内存，由于 align 的要求我们再加上 4 字节的 padding，<br>一共 16 字节，并为 100 个 i64 元素在堆上分配 100 * 8 字节的内存</p>
<p>而每次执行<code>a[i]</code>这样的操作时，我们会对取 a 的地址 并加上 8，得到指向对应连续内存的指针 <strong><em>p</em></strong> ，<br>再对 <strong>p + i _ sizeof(i64)</strong> 对应的地址指向读&#x2F;写操作</p>
<p>对应到 LLVM 的 CodeGen，我们则需要定义形如<code>StructType&lt;i64,PointerTo&lt;xxx&gt;&gt;</code>这样的类型，<br>并用<strong>getelementptr inbound</strong>和<strong>getelementptr</strong>指令获得某个元素的地址</p>
<p>这样设计的好处则是将长度 length 放到栈上，不需要在堆分配和取元素时进行额外的计算，<br>也不需要 align 来保证 cache friendly，同时也方便优化。</p>
<p>而相较于 C 语言风格的数组，我们的数组主体始终放在堆上，故内存的管理不够精细，<br>但经过了封装，其易用性更胜一筹，基于这些限制，其优化也更容易实现。</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
</search>
