<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mathematica微积分常用命令</title>
    <url>/2023/02/06/Mathematica%E5%BE%AE%E7%A7%AF%E5%88%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>作为大一新生,每天都要为了数学作业焦头烂额，为了解决这个问题，聪慧的我想到了利用数学工具 Mathematica 来解决这个问题</p>
<p>于是我先用南大邮箱获得了 mma，并在 Ubuntu 上安装了 mma 及其依赖</p>
<p>下面记录有关求极限，求微分，以及求积分的几个模板</p>
<span id="more"></span>

<h2 id="极限-Limit"><a href="#极限-Limit" class="headerlink" title="极限(Limit)"></a>极限(Limit)</h2><p>我们要求得下列式子的极限：</p>
<p>$Assume {\quad} f’(a)&#x3D;\sqrt{2} {\quad} f’’(a)&#x3D;2$</p>
<p>$\lim_{x \rightarrow a} \frac{1}{f(x)-f(a)} - \frac{1}{(x-a)f’(x)} $</p>
<p>我们在 mma 可以输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Limit</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span> <span class="operator">-</span> <span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="punctuation">(</span><span class="variable">x</span> <span class="operator">-</span> <span class="variable">a</span><span class="punctuation">)</span> <span class="variable">f</span><span class="operator">&#x27;</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">x</span> <span class="operator">-&gt;</span> <span class="variable">a</span><span class="operator">,</span></span><br><span class="line"> <span class="built_in">Assumptions</span> <span class="operator">-&gt;</span> <span class="punctuation">&#123;</span><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="built_in">Sqrt</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">D</span><span class="punctuation">[</span><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">[</span><span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">a</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="微分-x2F-导数-Derivative"><a href="#微分-x2F-导数-Derivative" class="headerlink" title="微分&#x2F;导数(Derivative)"></a>微分&#x2F;导数(Derivative)</h2><p>我们要求得下列函数的导数：</p>
<p>$f(x)&#x3D;\sin{x}^{\sin{x}}+\ln{\int_0^x{\sqrt{\tan{x}}dx}}$</p>
<p>我们在 mma 可以输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">[</span><span class="type">_x</span><span class="punctuation">]</span><span class="operator">=...</span></span><br><span class="line"><span class="built_in">D</span><span class="punctuation">[</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">x</span><span class="punctuation">)</span><span class="operator">,</span><span class="variable">x</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="积分-x2F-定积分-Integration"><a href="#积分-x2F-定积分-Integration" class="headerlink" title="积分&#x2F;定积分(Integration)"></a>积分&#x2F;定积分(Integration)</h2><p>我们要求得以下积分</p>
<p>$\int{\frac{1}{\cos^2{x}}dx}$</p>
<p>$\int_0^{\pi&#x2F;2}{\frac{1}{\cos^2{x}}dx}$</p>
<p>我们可以分别在 mma 输入以下代码</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Integrate</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">,</span><span class="variable">x</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">Integrate</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">/</span><span class="punctuation">(</span><span class="built_in">Cos</span><span class="punctuation">[</span><span class="variable">x</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">,</span><span class="punctuation">&#123;</span><span class="variable">x</span><span class="operator">,</span><span class="number">0</span><span class="operator">,</span><span class="built_in">Pi</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Mathematica</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(1)</title>
    <url>/2023/02/06/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-1/</url>
    <content><![CDATA[<p>网上有关Neovim API的中文资料实在稀缺，在此特意整理一部分</p>
<p>若英文水平过关，可以直接输入指令 <code>:h lua guide</code> 获得Neovim的Lua API相关英文文档</p>
<span id="more"></span>

<h2 id="Neovim’s-Lua-API"><a href="#Neovim’s-Lua-API" class="headerlink" title="Neovim’s Lua API"></a>Neovim’s Lua API</h2><ul>
<li><p><code>vim.keymap.set(mode , from_keys, to_expr, opts)</code></p>
<p> <em>作用:创建一个键位映射</em></p>
<p> <strong>mode</strong>：类型：<strong>string</strong>，映射作用的模式，”n”代表normal，”i”代表insert,”v”代表visual</p>
<p> <strong>from_keys</strong>：类型：<strong>string</strong>，则指被映射的按键</p>
<p> <strong>to_expr</strong>：类型：<strong>any</strong>，指映射得到的键位，vim表达式，或者Lua函数</p>
<p> <strong>opts</strong>：类型：<strong>table</strong>，键位映射有关的设置</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>vim.api.nvim_create_user_command(commandName, expr)</code></p>
<p> <em>作用:创建一个用户命令</em></p>
<p> <strong>commandName</strong>：类型：<strong>string</strong>， 命令名(必须首字母大写)</p>
<p> <strong>expr</strong>：类型：<strong>any</strong>，命令执行的键位，表达式或者Lua函数</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>vim.api.nvim_create_autocmd(event, opts)</code></p>
<p>  <em>作用:创建一个自动命令</em></p>
<p>  <strong>event</strong>：类型：<strong>string</strong>， 自动命令组(autogroup)</p>
<p>  <strong>opts</strong>：类型：<strong>table</strong>，相关设置：</p>
<ul>
<li><p><strong>pattern</strong>: 文件名的pattern</p>
</li>
<li><p><strong>callback</strong>: 自动命令的回调函数，可以是键位，vim表达式，或者Lua函数</p>
</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(2)</title>
    <url>/2023/02/08/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-2/</url>
    <content><![CDATA[<h3 id="使用-Lua-配置-Neovim，并设置自己的-workflow"><a href="#使用-Lua-配置-Neovim，并设置自己的-workflow" class="headerlink" title="使用 Lua 配置 Neovim，并设置自己的 workflow"></a>使用 Lua 配置 Neovim，并设置自己的 workflow</h3><h4 id="结合命令行工具"><a href="#结合命令行工具" class="headerlink" title="结合命令行工具"></a>结合命令行工具</h4><p>我在编码时常常有使用 git 的需求，但又不想总是在命令行中敲命令</p>
<p>于是我利用与 ToggleTerm 把命令行工具 lazygit 嵌入至 Neovim 中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> Terminal = <span class="built_in">require</span>(<span class="string">&#x27;toggleterm.terminal&#x27;</span>).Terminal</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lazygit = Terminal:new(&#123; cmd = <span class="string">&quot;lazygit&quot;</span>, direction = <span class="string">&#x27;float&#x27;</span>, hidden = <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">local</span> top = Terminal:new(&#123; cmd = <span class="string">&quot;top&quot;</span>, direction = <span class="string">&#x27;float&#x27;</span>, hidden = <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lazygit</span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;LazyGit&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        lazygit:toggle()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; nargs = <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- top</span></span><br><span class="line">vim.api.nvim_create_user_command(<span class="string">&quot;Top&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        top:toggle()</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; nargs = <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>同样类似的，还可以通过命令行工具 trans 进行翻译，并通过 neovim 的 api 将翻译结果显示出来.</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">translate_terminal</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> mode = vim.api.nvim_get_mode()[<span class="string">&#x27;mode&#x27;</span>]</span><br><span class="line">    <span class="keyword">local</span> to_translate</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&#x27;n&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        to_translate = vim.fn.expand(<span class="string">&#x27;&lt;cword&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> mode == <span class="string">&#x27;v&#x27;</span> <span class="keyword">then</span></span><br><span class="line">        to_translate = <span class="built_in">require</span>(<span class="string">&#x27;basic&#x27;</span>).get_visual_selection()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> command = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&#x27;trans &quot;%s&quot;&#x27;</span>, to_translate)</span><br><span class="line"></span><br><span class="line">    async.run(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="keyword">local</span> translated_content = vim.fn.systemlist(command)</span><br><span class="line">        utils.show_term_content(translated_content)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="设置-Layout"><a href="#设置-Layout" class="headerlink" title="设置 Layout"></a>设置 Layout</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vim.api.nvim_create_user_command(</span><br><span class="line">    <span class="string">&quot;BufferDelete&quot;</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">---@diagnostic disable-next-line: missing-parameter</span></span><br><span class="line">        <span class="keyword">local</span> file_exists = vim.fn.filereadable(vim.fn.expand(<span class="string">&quot;%p&quot;</span>))</span><br><span class="line">        <span class="keyword">local</span> modified = vim.api.nvim_buf_get_option(<span class="number">0</span>, <span class="string">&quot;modified&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file_exists == <span class="number">0</span> <span class="keyword">and</span> modified <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> user_choice = vim.fn.<span class="built_in">input</span>(</span><br><span class="line">                    <span class="string">&quot;The file is not saved, whether to force delete? Press enter or input [y/n]:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> user_choice == <span class="string">&quot;y&quot;</span> <span class="keyword">or</span> <span class="built_in">string</span>.<span class="built_in">len</span>(user_choice) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                vim.cmd(<span class="string">&quot;bd!&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> force = <span class="keyword">not</span> vim.bo.buflisted <span class="keyword">or</span> vim.bo.buftype == <span class="string">&quot;nofile&quot;</span></span><br><span class="line"></span><br><span class="line">        vim.cmd(force <span class="keyword">and</span> <span class="string">&quot;bd!&quot;</span> <span class="keyword">or</span> <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;bp | bd! %s&quot;</span>, vim.api.nvim_get_current_buf()))</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123; desc = <span class="string">&quot;Delete the current Buffer while maintaining the window layout&quot;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="在-Neovim-中编辑-Hexo-blog"><a href="#在-Neovim-中编辑-Hexo-blog" class="headerlink" title="在 Neovim 中编辑 Hexo blog"></a>在 Neovim 中编辑 Hexo blog</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> blog_path = <span class="string">&quot;~/Documents/Hexo-Blog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogNew</span><span class="params">(input)</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;nvim-tree.api&#x27;</span>).tree.change_root(blog_path)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">output</span> = vim.fn.system(<span class="string">&quot;hexo n &quot;</span> .. <span class="string">&#x27;\&quot;&#x27;</span> .. <span class="built_in">input</span>.args .. <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vim.v.shell_error == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">path</span> = <span class="built_in">string</span>.<span class="built_in">sub</span>(<span class="built_in">output</span>, <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">output</span>, <span class="string">&#x27;~&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>), <span class="number">-1</span>)</span><br><span class="line">        vim.cmd(<span class="string">&quot;:e &quot;</span> .. <span class="built_in">path</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Failed creating new blog post&quot;</span> .. <span class="built_in">input</span>.args, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogNewDraft</span><span class="params">(input)</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;nvim-tree.api&#x27;</span>).tree.change_root(blog_path)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">output</span> = vim.fn.system(<span class="string">&quot;hexo new draft &quot;</span> .. <span class="string">&#x27;\&quot;&#x27;</span> .. <span class="built_in">input</span>.args .. <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vim.v.shell_error == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> <span class="built_in">path</span> = <span class="built_in">string</span>.<span class="built_in">sub</span>(<span class="built_in">output</span>, <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">output</span>, <span class="string">&#x27;~&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>), <span class="number">-1</span>)</span><br><span class="line">        vim.cmd(<span class="string">&quot;:e &quot;</span> .. <span class="built_in">path</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Failed creating new blog post&quot;</span> .. <span class="built_in">input</span>.args, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">blogGenerateAndDeploy</span><span class="params">()</span></span></span><br><span class="line">    vim.api.nvim_set_current_dir(blog_path)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;hexo g &amp;&amp; hexo s&quot;</span>)) <span class="keyword">then</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Deploy the blog successfully&quot;</span>, <span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        vim.notify(<span class="string">&quot;Deployment of blog failed&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="取消下一行注释"><a href="#取消下一行注释" class="headerlink" title="取消下一行注释"></a>取消下一行注释</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- avoid comment when enter the new line</span></span><br><span class="line">vim.api.nvim_create_autocmd(&#123; <span class="string">&quot;BufEnter&quot;</span> &#125;, &#123;</span><br><span class="line">    pattern = <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        vim.opt.formatoptions = vim.opt.formatoptions - &#123; <span class="string">&quot;c&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;o&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim常用配置(3) (clangd &amp; CMake)</title>
    <url>/2023/03/01/Neovim%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE-3-Clangd---CMake/</url>
    <content><![CDATA[<p>在使用 Neovim 进行 C&#x2F;C++的开发时，我们常常使用 <strong>clangd</strong> 作为 <strong>lsp</strong> 提供语法高亮&#x2F;重构等语言服务</p>
<p>其中 clangd 根据自动推断宏的功能也是十分有效，搭配<strong>CMake</strong>可以达到更加好的效果(如支持 CMake 内置宏，支持自动 include CMake 配置的头文件)</p>
<p>下面提供简要的集成 clangd 与 cmake 的方法</p>
<p>一般来说<strong>clangd</strong>可以自动识别<strong>CMake</strong>生成的<strong>compile_commands.json</strong>来进行头文件的识别与宏的分析</p>
<p>但 compile_commands.json 不会自动生产，故我们可以通过以下命令实现 compile_commands 的自动生产</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake . -G -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br></pre></td></tr></table></figure>

<p>其中 <em><code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code></em> 是用于导出编译命令的 flag</p>
<p>故我常常会在项目目录下建立一个 build.sh 来构建项目:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake . -G -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>构建时只需要输入 build.sh</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-Mutable Variable的LLVM IR生成</title>
    <url>/2023/03/03/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-Mutable-Variable%E7%9A%84LLVM-IR%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h3 id="为什么需要-Mutable-Variable"><a href="#为什么需要-Mutable-Variable" class="headerlink" title="为什么需要 Mutable Variable?"></a>为什么需要 Mutable Variable?</h3><p>由于 LLVM 内部优化等原因，LLVM IR 中的寄存器必须遵循<strong>SSA</strong>原则，即每个寄存器在 SSA 中仅被赋值一次。</p>
<p>但由于 XSharp 需要支持同个变量的多次引用，我们不能直接使用寄存器作为变量的存储单元。</p>
<p>幸运的是，LLVM 并不强制要求栈上的变量保持<strong>SSA</strong>，所以我们可以考虑将所有变量存放在栈上，</p>
<p>然后再通过 LLVM 提供的 Mem2Reg 工具或者 Pass 进行栈上内存的数据流分析，尽可能地将栈上的变量转换至寄存器上。</p>
<p>原文档在此:<a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">LLVM Mutable Variable</a></p>
<p>而针对 XSharp,我们可以写出如下代码</p>
<span id="more"></span>

<p>首先，LLVM 通过<strong>AllocaInst</strong>分配栈上的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VariableDeclarationNode* varNode = <span class="built_in">get</span>();</span><br><span class="line">TypeNode* typenode = varNode-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> xsharpType = varNode-&gt;<span class="built_in">type</span>();</span><br><span class="line"><span class="keyword">auto</span> llvmValue =</span><br><span class="line">builder.<span class="built_in">CreateAlloca</span>(</span><br><span class="line">    <span class="built_in">llvmTypeFor</span>(xsharpType, context), <span class="literal">nullptr</span>,</span><br><span class="line">    varNode-&gt;<span class="built_in">name</span>().<span class="built_in">toStdString</span>());</span><br></pre></td></tr></table></figure>

<p>同时，也可以把函数的参数存在栈上，以下复制自 <a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">LLVM Tutorial</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>并用<strong>PromoteMemoryToRegisterPass</strong>实现 Mem2Reg 的优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promote allocas to registers.</span></span><br><span class="line">functionPassManager-&gt;<span class="built_in">add</span>(<span class="built_in">createPromoteMemoryToRegisterPass</span>());</span><br></pre></td></tr></table></figure>

<p>LLVM 也对性能等问题做了解释<br><img src="/images/Mem2RegLLVM.png" alt="content"></p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-Type</title>
    <url>/2023/02/18/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-Type/</url>
    <content><![CDATA[<h3 id="一个好的编程语言需要有一个好的类型系统"><a href="#一个好的编程语言需要有一个好的类型系统" class="headerlink" title="一个好的编程语言需要有一个好的类型系统"></a>一个好的编程语言需要有一个好的类型系统</h3><p>笔者计划为 XSharp 开发一个静态且可拓展的类型系统，其中支持基本类型(如<em>i32</em>,<em>i64</em>)，数组，函数，Closure，类等类型及其复合</p>
<p>而复合的需求就意味着类型必须是多层次，且多种类型的形式，而树这种数据结构正好符合要求</p>
<p>于是<strong>TypeNode</strong>出现了</p>
<p>我们社设计具体类型的<strong>类型相关</strong>设置，从而构建不同的类型结构，如 ArrayType 有 elementType 的子类型，FunctionType 有 paramTypes 的子节点列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arrayDimension指的是数组类型的维度</span></span><br><span class="line"><span class="comment">//而elementType则是元素类型的TypeNode指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayType</span> &#123;</span><br><span class="line">    uint arrayDimension;</span><br><span class="line">    TypeNode* elementType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//paramTypes指的是参数的类型</span></span><br><span class="line"><span class="comment">//returnValueType则是返回值的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FunctionType</span> &#123;</span><br><span class="line">    std::vector&lt;TypeNode*&gt; paramTypes;</span><br><span class="line">    TypeNode* returnValueType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>而<strong>TypeNode</strong>则用枚举<strong>Category</strong>表示类型的范畴，即<strong>类型相关</strong>的类型设置(<strong>typeSpecifiedInfo</strong>)的范畴</p>
<p>从而确定 TypeNode 的类型结构，使用<strong>std::variant</strong>使存储多种类型相关设置成为可能</p>
<p>搭配上<strong>Category</strong>，就可根据<strong>category</strong>解析 variant 类型的<strong>typeSpecifiedInfo</strong>，获得具体的类型信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeNode</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypeNode</span>();</span><br><span class="line">    <span class="built_in">TypeNode</span>(<span class="type">const</span> TypeNode&amp; other);</span><br><span class="line">    ~<span class="built_in">TypeNode</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equals</span><span class="params">(<span class="type">const</span> TypeNode&amp; other)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Basic type</span></span><br><span class="line">    <span class="function">BasicType <span class="title">basicType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function type, TODO complete below</span></span><br><span class="line">    <span class="function">TypeNode* <span class="title">returnValueType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;TypeNode*&gt; <span class="title">paramsType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array type, TODO complete below</span></span><br><span class="line">    <span class="function">uint <span class="title">arrayDimension</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">TypeNode* <span class="title">elementType</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class type,  TODO complete below</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate a unique name for a type</span></span><br><span class="line">    <span class="function">XString <span class="title">typeName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    uint typeID;</span><br><span class="line">    XString baseName;</span><br><span class="line">    <span class="type">bool</span> isConst;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Categories</span> &#123; Basic, Array, Function, Closure, Class &#125; category;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;BasicType, ClassType, FunctionType, ArrayType, ClosureType&gt;</span><br><span class="line">        typeSpecifiedInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时注意到<strong>typeID</strong>，我们将会在编译时为特定类型分配<strong>唯一</strong>(<strong>unique</strong>)的 typeID，并通过 typeID 实现运行时反射</p>
<p>在 TypeSystem 中我们将实现这一功能</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<p>&lt;–more&gt;</p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog&#39;s configuration</category>
      </categories>
      <tags>
        <tag>Helloworld</tag>
        <tag>Blog&#39;s configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客文章</title>
    <url>/2023/02/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>奋战了 2 个小时后，终于成功用 Hexo 搭建了一个小博客。<br>本博客仅用于个人生活学习的记录，并无商业用途，若有友链或者交流需要，请通过我的邮箱<strong><a href="mailto:&#120;&#x78;&#115;&#x5f;&#99;&#104;&#x79;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#x2e;&#99;&#111;&#109;">&#120;&#x78;&#115;&#x5f;&#99;&#104;&#x79;&#x40;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#x6f;&#107;&#x2e;&#99;&#111;&#109;</a></strong>联系我</p>
]]></content>
      <categories>
        <category>Blog&#39;s configuration</category>
      </categories>
      <tags>
        <tag>Helloworld</tag>
        <tag>Blog&#39;s configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-表达式解析-Pratt Parsing</title>
    <url>/2023/03/15/XSharp%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90-Pratt-Parsing/</url>
    <content><![CDATA[<p>手工实现 Parser 常用<strong>递归下降法(Recusive Descent)</strong>，XSharp 的 Parser 也采用了<strong>递归下降</strong>的主体结构。</p>
<p>一般来说递归下降法适用于自上而下的结构，更容易解析开头有标识符的语言，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但也由于同样的原因，递归下降法处理表达式非常吃力。Parser 在读到表达式开头的时候，无法知道自己身处哪种表达式之中，这是因为操作符往往在表达式的中间位置（甚至结尾），比如加法运算的+、函数调用的()。为了能自顶向下地解析表达式，你需要将每一种操作符 <strong>优先级(priority)</strong> 都单独作为一个层级，为其编写解析函数，并手动处理 <strong>结合性(associativity)</strong> ，因此解析函数会比较多、比较复杂。</p>
<p>所以在重构 XSharp 的 Parser 时，我选择了 <strong>Pratt Parsing</strong> 作为表达式的算法</p>
<p>笔者参考了 <a href="https://zhuanlan.zhihu.com/p/471075848">Pratt Parsing 知乎</a> 和 <a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">Pratt Parsing Rust</a> 进行了有关代码的重构</p>
<p>核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ASTNode* lhs = <span class="built_in">operand</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isStopwords</span>(current, stopwords)) <span class="keyword">return</span> lhs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;type != Operator)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">XSharpError</span>(<span class="string">&quot;No operator matched after operand&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">priority</span>(current-&gt;value) &lt;= ctxPriority) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    XString op = current-&gt;value;</span><br><span class="line"></span><br><span class="line">    forward();</span><br><span class="line">    <span class="keyword">auto</span> right_binding_power =</span><br><span class="line">        <span class="built_in">assoc</span>(op) == LeftToRight ? <span class="built_in">priority</span>(op) : <span class="built_in">priority</span>(op) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> rhs = <span class="built_in">expression</span>(stopwords, right_binding_power);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> new_lhs = <span class="keyword">new</span> BinaryOperatorNode;</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setOperatorStr</span>(op);</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setLeft</span>(lhs);</span><br><span class="line">    new_lhs-&gt;<span class="built_in">setRight</span>(rhs);</span><br><span class="line">    lhs = new_lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lhs;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>原理如下：</p>
<p>我们在解析表达式时，我们总是倾向于让<strong>priority</strong>较高的运算符与<strong>operand</strong>结合</p>
<p>故我们在已知左边表达式 lhs 时，从人类通常思维出发</p>
<p>我们倾向于在 op 的 priority 较高时拆散 lhs，让 op 不断与 lhs 最右边的 operand 结合直到优先级不足</p>
<p>而在 op 的 priority 较低时，让 op 与 lhs 整体结合</p>
<p>但这不符合机器从左到右解析的顺序，所以我们可以换一种思路</p>
<p>所以，我们从左向右扫描，设初始优先级为 0，从 priority 较低的层级出发，一步步找到优先级更高的运算符并结合</p>
<p>以表达式 <code>a / b = 2 + 5 * 6</code> 为例</p>
<p>初始层级优先级为 0，给当前层级命名 <strong>initial</strong></p>
<ul>
<li><p>进入 initial 层，我们先读入 token <strong>a</strong></p>
<p>发现 <strong>/</strong> 的优先级大于 0，于是结合 0 与/<br>并进入属于 <strong>‘/’</strong> 的层级，该层级优先级为 3，该层级求优先级大于 3 的 rhs</p>
<ul>
<li><p>然后读入 token <strong>b</strong>, b 属于 <strong>‘/’</strong> 层级，又读入 operator <strong>=</strong> 发现其优先级&lt;=当前层级最小优先级</p>
<p>于是结束 <strong>‘/’</strong> 层级， 确定其 rhs 为 b，得到一个整体 <code>(a / b)</code></p>
</li>
</ul>
</li>
<li><p>回到 initial 层，且此时 lhs 为<code>a / b</code>，继续读入 operator <strong>=</strong> ，其优先级为 1&gt;=0，故进入 <strong>‘=’</strong> 层</p>
<ul>
<li><p>现在读入 token <strong>2</strong>，再读入 operator <strong>+</strong>，发现其优先级 2&gt;=1 故可作为 rhs，进入 <strong>‘+’</strong> 层</p>
<ul>
<li><p>继续求 <strong>‘+’</strong> 的 rhs，发现 token <strong>5</strong>，和 operator <strong>*</strong> ，<strong>*</strong> 的优先级 3&gt;=2，故进入<strong>‘*‘</strong>层</p>
<ul>
<li>读入 <code>6</code> 表达式结束，将 6 作为 <strong>‘*‘</strong> 的 rhs，开始回溯</li>
</ul>
<p>将 <code>5 * 6</code> 作为 <strong>‘+’</strong> 的 rhs，退出 <strong>‘+’</strong> 层</p>
</li>
</ul>
<p>得到 <code>2 + (5*6)</code> ，将其作为 <strong>‘=’</strong> 的 rhs，退出 <strong>‘=’</strong> 层</p>
</li>
</ul>
</li>
</ul>
<p>最后回到<strong>initial</strong>层，结合已有 lhs：<code>a / b</code>, op: <code>=</code>, rhs <code>2 + ( 5 * 6 )</code>，返回<code>(a / b) = ( 2 + ( 5 * 6 ) )</code></p>
<p>至此基本算法结束，对于右结合的<strong>associativity</strong>可以通过降低其’右优先级‘来实现（如代码所示），其他高级特性可参考上面引用的文章</p>
<p>通过这个算法，我们成功把原本 200 行的复杂函数压缩到 20 行，且获得了更高的性能。</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp-4-Class-Design</title>
    <url>/2023/05/18/XSharp-4-Class-Design/</url>
    <content><![CDATA[<p>Waiting to complete</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>XSharp开发思路-数组设计</title>
    <url>/2023/04/17/XSharp-3-Array-Design-0/</url>
    <content><![CDATA[<p>参考了 Java 中的对象模型<br>我决定把 XSharp 中的 <strong>数组(Array)</strong> 的模型设计为以下形式：<br>[ <strong>8</strong> bytes ] object header as <strong>length of array</strong><br>[ <strong>4 or 8</strong> bytes ] pointer <strong><em>p</em></strong> to a sequential memory (<strong>for elements</strong>)</p>
<p>故对以下 XSharp 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i64[] a = new i64[100]</span><br></pre></td></tr></table></figure>

<p>在 64 位系统上，我们将会在栈上分配 8 + 4 字节的内存，由于 align 的要求我们再加上 4 字节的 padding，<br>一共 16 字节，并为 100 个 i64 元素在堆上分配 100 * 8 字节的内存</p>
<p>而每次执行<code>a[i]</code>这样的操作时，我们会对取 a 的地址 并加上 8，得到指向对应连续内存的指针 <strong><em>p</em></strong> ，<br>再对 <strong>p + i _ sizeof(i64)</strong> 对应的地址指向读&#x2F;写操作</p>
<p>对应到 LLVM 的 CodeGen，我们则需要定义形如<code>StructType&lt;i64,PointerTo&lt;xxx&gt;&gt;</code>这样的类型，<br>并用<strong>getelementptr inbound</strong>和<strong>getelementptr</strong>指令获得某个元素的地址</p>
<p>这样设计的好处则是将长度 length 放到栈上，不需要在堆分配和取元素时进行额外的计算，<br>也不需要 align 来保证 cache friendly，同时也方便优化。</p>
<p>而相较于 C 语言风格的数组，我们的数组主体始终放在堆上，故内存的管理不够精细，<br>但经过了封装，其易用性更胜一筹，基于这些限制，其优化也更容易实现。</p>
]]></content>
      <categories>
        <category>XSharp</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>XSharp</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次给LLVM的Contribution</title>
    <url>/2023/06/30/LLVM-First-Contribution/</url>
    <content><![CDATA[<h2 id="为什么要参与LLVM的开源？"><a href="#为什么要参与LLVM的开源？" class="headerlink" title="为什么要参与LLVM的开源？"></a>为什么要参与LLVM的开源？</h2><p>由于一直以来对编译器后端特别感兴趣，又曾用<strong>LLVM</strong>作为后端为自己的语言进行AOT的编译，<br>我对LLVM的内部十分好奇，于是想通过为<strong>LLVM</strong>贡献代码的方式了解<strong>LLVM</strong>，并了解编译器优化的流程。</p>
<p>于是我参考了一位LLVM Member的文章:<br><a href="https://developers.redhat.com/articles/2022/12/20/how-contribute-llvm#implementing_the_transform">How to contribute to llvm?</a></p>
<p>以下则是我从编译到提交patch的全流程。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>要为LLVM贡献代码，那首先能在本地编译LLVM库。</p>
<p>那么我们首先要clone LLVM的git仓库，或者自己fork了<strong>llvm-project</strong>后再clone到本地。二者区别不大，我按照github的开源习惯选了后者。</p>
<p>clone完之后我们开始编译，这边要注意的是：由于计算机编译速度的限制，我们一边建议进行<strong>Release</strong>编译。否则一次编译链接要长达几小时的时间。<br>以下是cmake的模板：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -GNinja -Bbuild -Hllvm \</span><br><span class="line">    -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; \</span><br><span class="line">    -DLLVM_TARGETS_TO_BUILD=&quot;all&quot; \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">    -DLLVM_ENABLE_ASSERTIONS=true \</span><br><span class="line">    -DLLVM_CCACHE_BUILD=true \</span><br><span class="line">    -DLLVM_USE_LINKER=lld</span><br></pre></td></tr></table></figure>

<p>其中Debug可通过<code>-debug</code> flag来进行，你可以在对应的代码位置用<code>errs() &lt;&lt; something</code>进行输出。</p>
<p>而ninja的编译速度相对较快，所以以下有构建和测试的shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Build LLVM</span></span><br><span class="line">ninja -Cbuild</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run all LLVM tests</span></span><br><span class="line">ninja -Cbuild check-llvm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run tests <span class="keyword">in</span> a specific directory.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v will <span class="built_in">print</span> additional information <span class="keyword">for</span> failures.</span></span><br><span class="line">build/bin/llvm-lit -v llvm/test/Transforms/InstCombine</span><br></pre></td></tr></table></figure>

<h3 id="选Issue"><a href="#选Issue" class="headerlink" title="选Issue"></a>选Issue</h3><p>由于我是LLVM领域的新手，不太可能一上来就砍大龙，所以我挑了个简单的任务。</p>
<span id="more"></span>
<p>而llvm-project包括许多子项目，包括LLVM本身、Clang编译器、LLD链接器、libc++标准库以及许多其他项目。即使在LLVM本身中也有不同的领域。主要分为与中端优化器与LLVM中间表示(IR)有关的项目，和与后端将IR转换为机器代码有关的项目。</p>
<p>而我对中端的了解比较多，而且中端优化的代码有许多corner cases，可以通过简单的几行代码解决这些cases，<br>所以本博客主要针对中端IR优化的<strong>InstCombine</strong>进行讨论，挑选的也是<a href="https://github.com/llvm/llvm-project/issues?q=is:open+is:issue+label:llvm:instcombine">InstCombine Issue</a>。<br>当然，LLVM还有许多其他容易解决的Issue，如：<a href="https://github.com/llvm/llvm-project/issues?q=is:open+is:issue+label:%22good+first+issue%22">good first issues</a>，Clang，Flang还有clang-tidy和clang-format等项目的Issue。</p>
<p>在这里我将展示我的一次LLVM贡献经历：<a href="https://reviews.llvm.org/D154126/new/">D154126</a></p>
<p>相关<a href="https://github.com/llvm/llvm-project/issues/62586">Issue</a>。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这篇Issue里提到的问题为: <code>(a &gt; b) | (a &lt; b)</code> 的优化会在 <code>b == 0</code> 时失效。</p>
<p>而一般的 <code>(a &gt; b) | (a &lt; b)</code> 会折叠为 <code>ZExt(a != 0)</code>，对应的LLVM-IR如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @src(i32 %A, i32 %B) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp sgt i32 %A, %B</span><br><span class="line">  %3 = zext i1 %2 to i32</span><br><span class="line">  %4 = icmp slt i32 %A, %B</span><br><span class="line">  %5 = zext i1 %4 to i32</span><br><span class="line">  %6 = or i32 %3, %5</span><br><span class="line">  ret i32 %6</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">define i32 @tgt(i32 %A, i32 %B) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp ne i32 %A, %B</span><br><span class="line">  %3 = zext i1 %2 to i32</span><br><span class="line">  ret i32 %3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但对于 <code>b == 0</code> 的case，其对应的InstCombine优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @src(i32 %A) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp sgt i32 %A, 0</span><br><span class="line">  %3 = zext i1 %2 to i32</span><br><span class="line">  %4 = lshr i32 %A, 31</span><br><span class="line">  %5 = or i32 %4, %3</span><br><span class="line">  ret i32 %5</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">define i32 @tgt(i32 %A) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp sgt i32 %A, 0</span><br><span class="line">  %3 = zext i1 %2 to i32 </span><br><span class="line">  %4 = lshr i32 %A, 31</span><br><span class="line">  %5 = or i32 %3, %4</span><br><span class="line">  ret i32 %5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说在这种情况下 <code>A &lt; 0</code> 被优化成了 <code>A &lt;&lt; 31</code>，而之前对应的 <code>A &lt; B | A &gt; B</code> 的<strong>Pattern Matching</strong>被破坏掉了。</p>
<p>在分析如何解决这个优化问题前，我们先了解LLVM的中端优化代码提交patch的特殊规则。</p>
<p>LLVM的patch由两部分组成，第一部分是<strong>impl</strong>前的<strong>misoptimization tests</strong>，第二部分则是<strong>impl</strong>以及应用<strong>impl</strong>后的<strong>tests</strong>。<br>这样分解patch的好处有以下2点：</p>
<ol>
<li>便于通过对tests的前后对比查看你实现的优化效果。</li>
<li>可以把tests作为单独的patch提交，这样能简单提高LLVM的测试量。</li>
</ol>
<p>除此之外，在你提交patch前，你还要证明你优化的正确性。</p>
<h4 id="证明Transform的正确性"><a href="#证明Transform的正确性" class="headerlink" title="证明Transform的正确性"></a>证明Transform的正确性</h4><p>一般来讲，我们会使用 <a href="https://github.com/AliveToolkit/alive2">alive2</a> 验证不同<strong>LLVM-IR</strong>的正确性，<a href="https://alive2.llvm.org/ce/">online</a>版。<br>本篇的Issue的alive2结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @src(i32 %0) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp sgt i32 %0, 0</span><br><span class="line">  %3 = zext i1 %2 to i32</span><br><span class="line">  %4 = lshr i32 %0, 31</span><br><span class="line">  %5 = or i32 %4, %3</span><br><span class="line">  ret i32 %5</span><br><span class="line">&#125;</span><br><span class="line">=&gt;</span><br><span class="line">define i32 @tgt(i32 %0) &#123;</span><br><span class="line">%1:</span><br><span class="line">  %2 = icmp ne i32 %0, 0</span><br><span class="line">  %3 = zext i1 %2 to i32</span><br><span class="line">  ret i32 %3</span><br><span class="line">&#125;</span><br><span class="line">Transformation seems to be correct!</span><br></pre></td></tr></table></figure>

<p>虽然<strong>alive2</strong>是确保LLVM转换正确性的非常重要的工具，但值得注意的是它可能会产生<strong>false negative</strong>结果（即有时它会声称一个不正确的转换是正确的）。这通常发生在循环优化的背景下，并且通常不会影响<strong>InstCombine</strong>优化。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在我们写<strong>impl</strong>之前，我们需要先完成所有testcases的构建。</p>
<p>首先是基本成功转换的测试样例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @icmp_slt_0_or_icmp_sgt_0_i32(i32 %x) &#123;</span><br><span class="line">; CHECK-LABEL: @icmp_slt_0_or_icmp_sgt_0_i32(</span><br><span class="line">; CHECK-NEXT:    [[B:%.*]] = icmp sgt i32 [[X:%.*]], 0</span><br><span class="line">; CHECK-NEXT:    [[X_LOBIT:%.*]] = lshr i32 [[X]], 31</span><br><span class="line">; CHECK-NEXT:    [[D:%.*]] = zext i1 [[B]] to i32</span><br><span class="line">; CHECK-NEXT:    [[E:%.*]] = or i32 [[X_LOBIT]], [[D]]</span><br><span class="line">; CHECK-NEXT:    ret i32 [[E]]</span><br><span class="line">;</span><br><span class="line">  %A = icmp slt i32 %x, 0</span><br><span class="line">  %B = icmp sgt i32 %x, 0</span><br><span class="line">  %C = zext i1 %A to i32</span><br><span class="line">  %D = zext i1 %B to i32</span><br><span class="line">  %E = or i32 %C, %D</span><br><span class="line">  ret i32 %E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，其中的<strong>CHECK-LABEL</strong>后的是testcase的函数名，<strong>CHECK-NEXT</strong>后则是经过转换后期望的IR，在测试时若不满足期望，则会返回失败的测试报告。<br>这里的测试是未进行优化时的结果，故<strong>CHECK</strong>的结果也自然是未优化的。<br>当然这里<strong>CHECK</strong>的内容不用自己直接输入，可以用llvm的脚本自动生成，脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">llvm/utils/update_test_checks.py --opt-bin build/bin/opt \</span><br><span class="line">    llvm/test/Transforms/InstCombine/and-or-icmps.ll</span><br></pre></td></tr></table></figure>

<p>这段脚本会用<strong>InstCombine</strong>对<code>and-or-icmps</code>的每个testcase进行一次优化，并把优化结果作为<strong>CHECK</strong>的IR插入到<code>and-or-icmps</code>中。</p>
<p>而上面的测试用例只考虑了i32的基本类型，这里我们再添加i64的测试类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i64 @icmp_slt_0_or_icmp_sgt_0_i64(i64 %x) &#123;</span><br><span class="line">  %A = icmp slt i64 %x, 0</span><br><span class="line">  %B = icmp sgt i64 %x, 0</span><br><span class="line">  %C = zext i1 %A to i64</span><br><span class="line">  %D = zext i1 %B to i64</span><br><span class="line">  %E = or i64 %C, %D</span><br><span class="line">  ret i64 %E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还需要一些反例(如改变左移的位数，把大于变为小于等)，防止我们的转换误优化，一例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i64 @icmp_slt_0_or_icmp_sgt_0_i64_fail2(i64 %x) &#123;</span><br><span class="line">; CHECK-LABEL: @icmp_slt_0_or_icmp_sgt_0_i64_fail2(</span><br><span class="line">; CHECK-NEXT:    [[B:%.*]] = icmp sgt i64 [[X:%.*]], 0</span><br><span class="line">; CHECK-NEXT:    [[C:%.*]] = lshr i64 [[X]], 62</span><br><span class="line">; CHECK-NEXT:    [[D:%.*]] = zext i1 [[B]] to i64</span><br><span class="line">; CHECK-NEXT:    [[E:%.*]] = or i64 [[C]], [[D]]</span><br><span class="line">; CHECK-NEXT:    ret i64 [[E]]</span><br><span class="line">;</span><br><span class="line">  %B = icmp sgt i64 %x, 0</span><br><span class="line">  %C = lshr i64 %x, 62</span><br><span class="line">  %D = zext i1 %B to i64</span><br><span class="line">  %E = or i64 %C, %D</span><br><span class="line">  ret i64 %E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可能还要考虑向量化的测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define &lt;2 x i64&gt; @icmp_slt_0_or_icmp_sgt_0_i64x2(&lt;2 x i64&gt; %x) &#123;</span><br><span class="line">  %A = icmp slt &lt;2 x i64&gt; %x, &lt;i64 0,i64 0&gt;</span><br><span class="line">  %B = icmp sgt &lt;2 x i64&gt; %x, &lt;i64 0,i64 0&gt;</span><br><span class="line">  %C = zext &lt;2 x i1&gt; %A to &lt;2 x i64&gt;</span><br><span class="line">  %D = zext &lt;2 x i1&gt; %B to &lt;2 x i64&gt;</span><br><span class="line">  %E = or &lt;2 x i64&gt; %C, %D</span><br><span class="line">  ret &lt;2 x i64&gt; %E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成这些testcases后我们进行一次commit。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>最终到了我们的实现部分，在实现之前，我们要进行有关的分析&#x2F;debug的工作。</p>
<p>我们在这里通过<code>build/bin/opt -passes=instcombine -S -debug src.ll</code>进行Debug，在不同函数中插入打印的函数，从而根据输出判断优化的代码位置。</p>
<p>经过一系列排查，我们可以发现当<code>b == 0</code>时无法优化的原因是在<br><strong>InstCombineAndOr.cpp</strong>中的<strong>transformZExtICmp</strong>函数会把<code>ZExt(a &lt; 0)</code>转化为<code>a &lt;&lt; 31</code>。</p>
<p>而优化 <code>a &lt; b | a &gt; b</code> 的函数<strong>foldAndOrOfICmpsUsingRanges</strong>无法识别<code>a &lt;&lt; 31</code>这样的语句，自然就无法优化了。<br>由于笔者并不是特别清楚InstCombine优化的顺序，故笔者选择在<strong>foldCastedBitwiseLogic</strong>中增加对<code>Zext(a &gt; 0) | a &lt;&lt; 31</code>的匹配，并进行对应的优化。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ( A &lt;&lt; (X - 1) ) | ((A &gt; 0) zext to iX)</span></span><br><span class="line"><span class="comment">// &lt;=&gt; A &lt; 0 | A &gt; 0</span></span><br><span class="line"><span class="comment">// &lt;=&gt; (A != 0) zext to iX</span></span><br><span class="line">Value *A;</span><br><span class="line">ICmpInst::Predicate Pred;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> MatchOrZExtICmp = [&amp;](Value *Op0, Value *Op1) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">match</span>(Op0, <span class="built_in">m_LShr</span>(<span class="built_in">m_Value</span>(A), <span class="built_in">m_SpecificInt</span>(Op0-&gt;<span class="built_in">getType</span>()-&gt;<span class="built_in">getScalarSizeInBits</span>() - <span class="number">1</span>))) &amp;&amp;</span><br><span class="line">       <span class="built_in">match</span>(Op1, <span class="built_in">m_ZExt</span>(<span class="built_in">m_ICmp</span>(Pred, <span class="built_in">m_Specific</span>(A), <span class="built_in">m_Zero</span>())));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LogicOpc == Instruction::Or &amp;&amp;</span><br><span class="line">  (<span class="built_in">MatchOrZExtICmp</span>(Op0, Op1) || <span class="built_in">MatchOrZExtICmp</span>(Op1, Op0)) &amp;&amp;</span><br><span class="line">  Pred == ICmpInst::ICMP_SGT) &#123;</span><br><span class="line">  Value *Cmp =</span><br><span class="line">      Builder.<span class="built_in">CreateICmpNE</span>(A, Constant::<span class="built_in">getNullValue</span>(A-&gt;<span class="built_in">getType</span>()));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ZExtInst</span>(Cmp, A-&gt;<span class="built_in">getType</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们定义了一个lambda：<code>MatchOrZExtICmp</code>，用于匹配左移与Zext运算，而<code>Op0</code>,<code>Op1</code>则是在<code>or</code>运算符的两个操作数。</p>
<p><code>match</code>、<code>m_ZExt</code>等有关的函数、类则是LLVM的<strong>PatternMatching</strong>库。<br><strong>PatternMatching</strong>库提供一系列函数和模板类，用于匹配特定LLVM-IR的Pattern，类似<code>m_SpecificInt</code>则是匹配一个特定整数或者有相同整数元素的向量<br>(<strong>Splat Vector</strong>)。</p>
<p>其中要注意的是<code>getScalarSizeInBits</code>函数在整数类型中返回整数的大小，而在vector中返回元素的大小。</p>
<p>最后经过了实现，我们需要再次更新我们的testcases以确认优化的效果，故要再次运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">llvm/utils/update_test_checks.py --opt-bin build/bin/opt \</span><br><span class="line">    llvm/test/Transforms/InstCombine/and-or-icmps.ll</span><br></pre></td></tr></table></figure>

<p>这时我们可以发现我们的正例的<strong>CHECK</strong>发生了变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define i32 @icmp_slt_0_or_icmp_sgt_0_i32(i32 %x) &#123;</span><br><span class="line">; CHECK-LABEL: @icmp_slt_0_or_icmp_sgt_0_i32(</span><br><span class="line">; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i32 [[X:%.*]], 0</span><br><span class="line">; CHECK-NEXT:    [[E:%.*]] = zext i1 [[TMP1]] to i32</span><br><span class="line">; CHECK-NEXT:    ret i32 [[E]]</span><br><span class="line">;</span><br><span class="line">  %A = icmp slt i32 %x, 0</span><br><span class="line">  %B = icmp sgt i32 %x, 0</span><br><span class="line">  %C = zext i1 %A to i32</span><br><span class="line">  %D = zext i1 %B to i32</span><br><span class="line">  %E = or i32 %C, %D</span><br><span class="line">  ret i32 %E</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且其他的testcases的变化也符合我们的期望，这里我们再commit一次。</p>
<p>这时我们就可以进入patch的提交阶段了。</p>
<h3 id="提交Patch"><a href="#提交Patch" class="headerlink" title="提交Patch"></a>提交Patch</h3><p>现在我们已经有了两个<strong>commit</strong>，可以通过以下指令生成test和impl的patch文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show -U99999 HEAD^ &gt; patch_test</span><br><span class="line">git show -U99999 &gt; patch_transform</span><br></pre></td></tr></table></figure>

<p>而LLVM暂时不接受Github的PR，只允许在<a href="https://reviews.llvm.org/">Phabricator</a>上提交patch。<br>故在这里我注册了Phabricator的帐号，并通过<a href="https://reviews.llvm.org/differential/diff/create/">Create Diff</a>分别上传我的两个patch。</p>
<p>Patch的标题内容等格式可以博客开头的参考文章，机翻并改造如下：</p>
<blockquote>
<p>选择一个有意义的patch标题和摘要。对于我们的运行示例，第一个patch可能是这样的：</p>
<p>title：[InstCombine] Add tests for (A &gt; 0) | (A &lt; 0) -&gt; zext (A !&#x3D; 0) fold (NFC)</p>
<p>summary：Tests for an upcoming (A &gt; 0) | (A &lt; 0) -&gt; zext (A !&#x3D; 0) fold.。</p>
<p>reviewer：（见下文）</p>
<p>第二个patch可能是这样的：</p>
<p>title：[InstCombine] Transform (A &gt; 0) | (A &lt; 0) -&gt; zext (A !&#x3D; 0) fold</p>
<p>summary：[InstCombine] Transform (A &gt; 0) | (A &lt; 0) -&gt; zext (A !&#x3D; 0) fold</p>
<p>This extends foldCastedBitwiseLogic to handle the similar cases.</p>
<p>……你的分析……</p>
<p>It’s proved by alive-tv:<strong>link</strong></p>
<p>Depends on DNNNNNN（在此处放置第一个patch的ID）。<br>reviewer：（见下文）</p>
<p>这里有几个值得强调的地方：</p>
<p>标题开头应该有一个 [Category] 标签。通常，您可以只使用您要修改的文件的名称。例如，对 InstCombine 的更改通常带有[InstCombine]标记。<br>非功能性更改（如测试添加）的patch通常在标题中的某个地方带有 NFC 标记。<br>如果您有任何 alive2 证明，请在patch摘要中包含它们。<br>您可以使用“Depends on DNNNNNN”来创建堆叠的patch。也可以事后添加“子修订版”来实现此目的。</p>
</blockquote>
<hr>
<p>现在我们还差<strong>Reviewers</strong>，在LLVM中，patch提交者负责选择适当的审阅者。虽然有人可能会根据patch标题（这就是分类标记如此重要的原因）来找到合适的审阅者，但您最好一开始就指定适当的审阅者。</p>
<p>虽然LLVM有一个CODE_OWNERS.txt文件，用于指定不同领域的代码所有者，但不幸的是，<br>这个文件往往过时且不完整。找到审阅者的更好方法是查看您要修改的文件的Git历史记录，并添加一些最近commit或最近review diff revision的人员。</p>
<p>对于InstCombine，主要的reviewer是spatel，但您也可以根据历史记录找到其他几个候选人（例如nikic，goldstein.w.n）。</p>
<p>提交了patch后，就该等待review了。对于这样简单的更改，通常会有人很快处理。如果您在一周内没有得到回复，请发送“ping”评论，并每周发送一次。对于InstCombine来说等待数周才进行审阅是相当不寻常的，但如果您提交的更改是很长时间没有人真正工作的领域，则可能会发生。只需要不断“ping”。</p>
<p>最后，一旦patch获得批准，审阅者通常会认为您已经拥有提交访问权限，并允许您自己提交更改。如果不是这种情况，则应该跟进一条评论，<br>例如“I don’t have commit access, can you please land this for me? Please use ‘Your Name &lt;your@email&gt;’ for the commit”。<br>最后一点很重要，因为Phabricator会丢失patch的作者信息，提交者必须将其添加回来。</p>
<p>如果您计划对LLVM进行任何形式的常规贡献，建议请求提交访问权限。这方面的门槛非常低，因此可以尽早请求。如果不必创建堆叠的审查，则测试的预提交工作流程要方便得多。</p>
<p>最后，有关CI的一些话：Phabricator上的patch会通过“pre-merge”测试运行。特别是如果您没有在本地运行完整的测试套件，则这些结果可能会有所帮助。不幸的是，这些测试运行有些不稳定，因此如果您看到与您的patch没有明显关系的失败，则通常可以忽略它们。</p>
<p>一旦patch被提交，它将在更广泛的“buildbots”范围内运行，这些机器人在许多不同的架构和许多不同的配置上运行测试。<br>这些也相当不稳定，因此同样适用：如果您收到buildbots故障电子邮件，看起来与您的patch无关，则不必担心。如果最终发现是您的责任，buildbots所有者会让您知道。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>翻译参考文章的总结</p>
</blockquote>
<p>LLVM的贡献过程具有某些不同于其他开源项目的不寻常方面。其中一部分是使用Phabricator而不是GitHub进行审查，但大多数差异都集中在强调正确性方面，从正确性证明开始，到测试的预提交工作流程，以及最终往往是测试和代码更改之间非常大的比率。</p>
<p>我希望本文对于想要进入LLVM开发的人有所帮助，但我想重申，第一次做不需要完全做得“正确”，如果遇到问题，人们会很乐意提供帮助。Discourse的初学者类别以及Discord聊天是提问的好地方。</p>
<blockquote>
<p>自己的总结</p>
</blockquote>
<p>第一次为大型开源项目Contribute是一次特别的经历，在不断与reviewer的沟通中，我也对LLVM的体系有了更深刻的了解，希望读者在看了本篇博客后也可以更活跃地参与开源活动。</p>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>LLVM</tag>
        <tag>OpenSource</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理-数据流分析-冗余消除</title>
    <url>/2023/07/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90-%E5%86%97%E4%BD%99%E6%B6%88%E9%99%A4/</url>
    <content><![CDATA[<p>本章博客将介绍一种消除程序代码冗余的编译器代码优化技术 — <strong>懒惰代码移动算法</strong></p>
<h2 id="什么是冗余消除"><a href="#什么是冗余消除" class="headerlink" title="什么是冗余消除"></a>什么是冗余消除</h2><p><strong>冗余消除</strong>就是要尽量减少表达式求值的次数，避免形如$x+y$的表达式在之后的代码中多次计算，影响性能。</p>
<p>冗余的来源主要有以下三种：</p>
<ol>
<li>公共子表达式 (<em>Common Expression</em>)</li>
<li>循环不变表达式 (<em>Loop Invariant</em>)</li>
<li>部分冗余表达式 (<em>Partial Redundancy Expression</em>)</li>
</ol>
<span id="more"></span>

<h3 id="全局公共子表达式"><a href="#全局公共子表达式" class="headerlink" title="全局公共子表达式"></a>全局公共子表达式</h3><p>若对于含有表达式如 $a+b$ 的基本块 $B$，任意到 $B$ 的路径都已经对 $a + b$ 求过值，则我们称这个表达式在 $B$ 中冗余，是公共的子表达式。<br>这样的表达式就不需要在 $B$ 中重新计算。</p>
<p><strong>注意</strong>，此时在 $a+b$ 被计算后，表达式中的分量 $a,b$ 不能在 $B$ 之前被重新定值，否则这样的表达式不是一个可用表达式。</p>
<h4 id="深层公共表达式"><a href="#深层公共表达式" class="headerlink" title="深层公共表达式"></a>深层公共表达式</h4><p>对于类似 $(a + b) ^ c + d$ 这样的更深层的子表达式，我们可以重复利用<strong>公共表达式消除技术</strong>直至没有新的公共表达式来找到这样的深层子表达式，<br>当然我们也可以参考常量传播框架来实现类似的搜索，当然也可以参考<strong>LLVM</strong>的模式匹配来达到同样的效果。</p>
<h3 id="循环不变表达式"><a href="#循环不变表达式" class="headerlink" title="循环不变表达式"></a>循环不变表达式</h3><p>假设 $a$，$b$ 没有在循环 $L$ 中重新定值，那么 $a+b$ 就是对于 $L$ 循环不变的，这样的循环不变式可以提出循环，减少不必要的计算。<br>以下是一个循环不变式的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (c)&#123;</span><br><span class="line">    print(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以转化为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">t = a + b</span><br><span class="line"><span class="keyword">while</span> (c)&#123;</span><br><span class="line">    print(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证 while 循环中循环不变表达式可以被优化，编译器通常把：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> c &#123;</span><br><span class="line">    S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> c &#123;</span><br><span class="line">    repeat</span><br><span class="line">        S;</span><br><span class="line">    until <span class="keyword">not</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样循环不变式可以放在 <em>repeat-util</em> 之前。</p>
<h3 id="部分冗余表达式"><a href="#部分冗余表达式" class="headerlink" title="部分冗余表达式"></a>部分冗余表达式</h3><p>对于以下基本块结构：<br><img src="/images/PartialReductancyEx.png" alt="content"></p>
<p>若 $B_2$ 中计算了 $a+b$ ，但 $B_3$ 中没有计算 $a+b$，$B_4$ 中计算了 $a+b$，那么</p>
<p>可以说在 $B_1 \rightarrow B_2 \rightarrow B_4$ 上 $a+b$ 冗余，<br>在$B_1 \rightarrow B_3 \rightarrow B_4$上 $a+b$ 不冗余，<br>那么该表达式对 $B_4$ 就是部分冗余的</p>
<p>对于这样部分冗余的表达式，我们需要在 $B_3$ 与 $B_4$ 之间插入新的基本块来计算 $a+b$ 。</p>
<h3 id="懒惰代码移动算法"><a href="#懒惰代码移动算法" class="headerlink" title="懒惰代码移动算法"></a>懒惰代码移动算法</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>为了解决部分冗余的问题，我们设计了懒惰代码移动算法，它有以下性质：</p>
<ol>
<li>所有不复制代码就可以消除的表达式冗余计算都被消除了</li>
<li>优化后的程序是正确的，不会执行原来程序不执行的任何计算</li>
<li>表达式的计算时刻尽量<strong>靠后</strong>，尽量靠后计算一个表达式可以降低其生命周期，也减少了其使用寄存器的时间，<br>这也是其被称为 <em>懒惰代码移动算法</em> 的原因。</li>
</ol>
<h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><ol>
<li><p>逆向数据流分析找到各个程序点上的 <em>预期执行(anticipated)</em> 的表达式。</p>
<blockquote>
<p><em>预期执行(anticipated)</em> 指的是：从程序点 $p$ 出发的所有路径都会计算 $a+b$ 的值，且 $b,c$ 的值就是他们在 $p$ 上的值</p>
<p>预期执行决定了一个表达式可以放的有多靠前，而一个表达式越靠前，能消除的冗余就越多</p>
</blockquote>
</li>
<li><p>将对表达式的计算放在满足下面条件的程序点上：总存在路径使得该点是此路径第一个<em>预期执行</em>该表达式的点。<br>我们称该表达式对该程序点*可用(Available)*，这个过程可以通过前向数据流分析完成。</p>
</li>
<li><p><em>后延</em>表达式，一个表达式可被<em>后延</em>到某个程序点的条件为：到该点的<strong>所有</strong>路径上，该表达式已经在程序点前<em>预期执行</em>，<br>但没有使用该表达式。该过程可以通过前向数据流分析完成。</p>
</li>
<li><p>最后使用简单的逆向数据流分析删除那些给程序中只使用一次的临时变量赋值语句。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Compiler Theory(编译原理)</category>
      </categories>
  </entry>
</search>
